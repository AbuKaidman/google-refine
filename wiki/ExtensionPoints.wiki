#summary How extensions can hook into various points in Gridworks (1.5 or later).

This document is for the upcoming version 1.5 and later only. This is still in flux.

Extensions that come with the code base are located under [http://code.google.com/p/freebase-gridworks/source/browse/#svn/trunk/extensions the extensions subdirectory], but when you develop your own extension, you can put its code anywhere as long as you refer to that directory in [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/WEB-INF/butterfly.properties the butterfly.properites file] through a `butterfly.modules.path` setting.

=Extension File Layout=

A typical extension sits in a file directory that contains the following files and sub-directories:

{{{
  src/
      com/foo/bar/... *.java source files
  module/
      *.html, *.vt files
      scripts/... *.js files
      styles/... *.css and *.less files
      images/... image files
      MOD-INF/
          lib/*.jar files
          classes/... java class files
          module.properties
          controller.js
}}}

The file named module.properties (see [http://code.google.com/p/freebase-gridworks/source/browse/trunk/extensions/sample-extension/module/MOD-INF/module.properties example]) contains the extension's metadata. Of importance is the name field, which gives the extension a name that's used in many other places to refer to it. This can be different from the extension's directory name. We'll use `my-extension` as an example for the rest of this document:

{{{
  name = my-extension
}}}

Also of importance is the dependency

{{{
  requires = core
}}}

which makes sure that the core module of Gridworks is loaded before the extension attempts to hook into it.

The file named controller.js is responsible for registering the extension's hooks into Gridworks. Look at the sample-extension extension's [http://code.google.com/p/freebase-gridworks/source/browse/trunk/extensions/sample-extension/module/MOD-INF/controller.js controller.js] file for an example. It should have a function called init() that does the hook registrations.

=Client-side Resources=

==Javascript and CSS==

The UI in Gridworks for working with a project is coded in [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/project.vt this file]. The file is quite small, and that's because almost all of its content is to be expanded dynamically through the Velocity variables $scriptInjection and $styleInjection. So that your own Javascript and CSS files get loaded, you need to register them with the ClientSideResourceManager. See [http://code.google.com/p/freebase-gridworks/source/browse/trunk/extensions/sample-extension/module/MOD-INF/controller.js this file] for an example.

In the registration call, the variable `module` is already available to your code by default, and it refers to your own extension.

{{{
   ClientSideResourceManager.addPaths(
        "project/scripts",
        module,
        [
            "scripts/foo.js",
            "scripts/subdir/bar.js"
        ]
    );
}}}

You can specify one or more files for registration, and their paths are relative to the `module` subdirectory of your extension. They are included in the order listed.

Javascript Bundling: Note that `project.vt` belongs to the core module and is thus under the control of the core module's
[http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/MOD-INF/controller.js controller.js file]. The Javascript files to be included in `project.vt` are by default bundled together for performance. When debugging, you can prevent this bundling behavior by setting `bundle` to `false` near the top of that `controller.js` file. (If you have commit access to this code base, be sure not to check that change in.)


==Images==

We recommend that you always refer to images through your CSS files rather than in your Javascript code. URLs to images will thus be relative to your CSS files, e.g.,

{{{
  .foo {
    background: url(../images/x.png);
  }
}}}

If you really really absolutely need to refer to your images in your Javascript code, then look up your extension's URL path in the global Javascript variable `ModuleWirings`:

{{{
  ModuleWirings["my-extension"] + "images/x.png"
}}}

==Client-side HTML Templates==

Beside Javascript, CSS, and images, your extension might also include HTML templates that get loaded on the fly by your Javascript code and injected into the page's DOM. For example, here is [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/scripts/dialogs/clustering-dialog.html the Cluster/Edit dialog template], which gets loaded by code in [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/scripts/dialogs/clustering-dialog.js this Javascript file]:

{{{
  var dialog = $(DOM.loadHTML("core", "scripts/dialogs/clustering-dialog.html"));
}}}

`DOM.loadHTML` returns the content of the file as a string, and `$(...)` turns it into a DOM fragment. Where `"core"` is, you would want your extension's name. The path of the HTML file is relative to your extension's `module` subdirectory.


=Project UI Extension Points=

Getting your extension's Javascript code included in `project.vt` doesn't accomplish much by itself unless your code also registers hooks into the UI. For example, you can surely implement an exporter in Javascript, but unless you add a corresponding menu command in the UI, your user can't use your exporter.

==Main Menu==

The main menu can be extended by calling any one of the methods `MenuBar.appendTo`, `MenuBar.insertBefore`, and `MenuBar.insertAfter`. Each method takes 2 arguments: an array of strings that identify a particular existing menu item or submenu, and one new single menu item or submenu or an array of menu items and submenus. For example, to insert 2 menu items and a menu separator before the menu item Project > Export Filtered Rows > Templating..., write this Javascript code wherever that would execute when your Javascript files get loaded:

{{{
    MenuBar.insertBefore(
        [ "core/project", "core/export", "core/export-templating" ],
        [
            {
                "label":"Menu item 1",
                "click": function() { ... }
            },
            {
                "label":"Menu item 2",
                "click": function() { ... }
            },
            {} // separator
        ]
    );
}}}

The array `[ "core/project", "core/export", "core/export-templating" ]` pinpoints the reference menu item.

See the beginning of [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/scripts/project/menu-bar.js this file] for IDs of menu items and submenus.

==Column Header Menu==

The drop-down menu of each column can also be extended, but the mechanism is slightly different compared to the main menu. Because the drop-down menu for a particular column is constructed on the fly when the user actually clicks the drop-down menu button, extending the column header menu can't really be done once at start-up time, but must be done every time a column header menu gets created. So, registration in this case involves providing a function that gets called each such time:

{{{
  DataTableColumnHeaderUI.extendMenu(function(column, columnHeaderUI, menu) { ... do stuff to menu ... });
}}}

That function takes in the column object (which contains the column's name), the column header UI object (generally not so useful), and the menu to extend. In the previous code line where it says "do stuff to menu", you can write something like this:

{{{
    MenuSystem.appendTo(menu, [ "core/facet" ], [
        {
            id: "core/text-facet",
            label: "My Facet on " + column.name,
            click: function() {
                ... use column.name and do something ...
            }
        },
    ]);
}}}

In addition to `MenuSystem.appendTo`, you can also call `MenuSystem.insertBefore` and `MenuSystem.insertAfter` which the same 3 arguments. To see what IDs you can use, see the function `DataTableColumnHeaderUI.prototype._createMenuForColumnHeader` in  [http://code.google.com/p/freebase-gridworks/source/browse/trunk/main/webapp/modules/core/scripts/views/data-table/column-header-ui.js this file].

=Server-side Extension Points=

==Ajax Commands==

The client-side of Gridworks gets things done by calling AJAX commands on the server-side. These commands must be registered with the Gridworks servlet, so that the servlet knows how to route AJAX calls from the client-side. This can be done inside the `init` function in your extension's `controller.js` file, e.g.,

{{{
  function init() {
      var GridworksServlet = Packages.com.google.gridworks.GridworksServlet;
      GridworksServlet.registerCommand("my-command", new Packages.com.foo.bar.MyCommand());
  }
}}}


==GEL==

GEL can be extended with new functions. This is also done in the `init` function in `controller.js`, e.g.,

{{{
  Packages.com.google.gridworks.gel.ControlFunctionRegistry.registerFunction(
        "functionName", new Packages.com.foo.bar.TheFunctionClass());
}}}

You might also want to provide new variables (beyond just `value`, `cells`, `row`, etc.) available to expressions. This is done by registering a binder that implements the interface `com.google.gridworks.expr.Binder`:

{{{
  Packages.com.google.gridworks.expr.ExpressionUtils.registerBinder(
        new Packages.com.foo.bar.MyBinder());
}}}

==Scripting Languages==

A scripting language (such as Jython) can be registered as follows:

{{{
    Packages.com.google.gridworks.expr.MetaParser.registerLanguageParser(
        "jython",
        "Jython",
        Packages.com.google.gridworks.jython.JythonEvaluable.createParser(),
        "return value"
    );
}}}

The first string is the prefix that gets prepended to each expression so that we know which language the expression is in. This should be short, unique, and identifying. The second string is a user-friendly name of the language. The third is an object that implements the interface `com.google.gridworks.expr.LanguageSpecificParser`. The final string is the default expression in that language that would return the cell's value.

==Importers==

{{{
  Packages.com.google.gridworks.commands.project.CreateProjectCommand.registerExporter(
      "format", new Packages.com.foo.bar.MyImporter());
}}}

==Exporters==

{{{
  Packages.com.google.gridworks.commands.project.ExportRowsCommand.registerExporter(
      "format", new Packages.com.foo.bar.MyExporter());
}}}


==Overlay Models==

TODO