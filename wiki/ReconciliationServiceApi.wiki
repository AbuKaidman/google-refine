#summary Specification for a standard reconciliation service API.

=Introduction=

A reconciliation service is a service that, given some text which is supposedly a name of something, and any additional details, returns a ranked list of potential entities matching that name. Entities are identified by strong identifiers in some particular identity space. For example, given the string "apple", a reconciliation service might return entities identified by "/en/apple", "/en/apple_inc", and "/en/apple_ii", in the Freebase ID space. Given the same string, another reconciliation service might return entities identified by URIs, which are in the URI space, so to speak. Some other identity spaces are ISBN, LSID. (Although ISBN and LSID identifiers are numbers, for uniformity, they are still stored as strings in Gridworks.)

Each reconciliation service can only reconcile to one single identify space, but several reconciliation services can reconcile to the same identity space.

So that it will be easy for users to plug in a variety of interchangeable reconciliation services, we define the API for a standard reconciliation service here.

Note: Reconciliation in Gridworks does not have to involve calling a reconciliation service through HTTP. It might involve opening a JDBC connection to a local SQL database. However, if you implement a standard reconciliation service API, then it can be used with the existing UI in Gridworks; users only need to plug in your API's URL.

A standard reconciliation service is a HTTP-based RESTful JSON-formatted API. It operates in 2 modes: single query mode and multiple query mode. The second is for optimization (reducing number of HTTP calls).

=Request=

==Single Query Mode==

A call to a standard reconciliation service API for a single query looks like this:

{{{
  http://foo.com/bar/reconcile?query={...json object literal...}
}}}

The json object literal has a few fields

|| "query" || a string to search for ||
|| "limit" || optional, an integer to specify how many results to return ||
|| "type" || optional, a single string, or an array of strings, specifying the types of result e.g., person, product, ... The actual format of each type depends on the service (e.g., "/government/policician" as a Freebase type) ||
|| "type_strict" || optional, a string, one of "any", "all", "should" ||
|| "properties" || optional, array of json object literals ||

Each json object literal of the "properties" array is of this form

{{{
  {
    "name" : string, property name, e.g., "country"
    "value" : string or number, e.g., "Japan", or object literal to carry a reconciled id
      {
        "id" : string
      }
    }
}}}

==Multiple Query Mode==

A call to a standard reconciliation service API for multiple queries looks like this:

{{{
  http://foo.com/bar/reconcile?queries={...json object literal...}
}}}

The json object literal has zero or more arbitrary key, each of which has a value in the same format as a single query, e.g.

{{{
  http://foo.com/bar/reconcile?queries={ "q1" : { "query" : "foo" }, "q2" : { "query" : "bar" } }
}}}

"q1" and "q2" can be arbitrary strings. 

=Response=

The response for a single query is a json literal object

{{{
  {
    "result" : [
      {
        "id" : ... string, database ID ...
        "name" : ... string ...
        "type" : ... array of strings ...
        "score" : ... double ...
        "match" : ... boolean, true if the service is quite confident about the match ...
      },
      ... more results ...
    ],
    ... potentially some useful envelope data, such as timing stats ...
  }
}}}

For multiple queries, the response is a json literal object with the same keys as in the request

{{{
  {
    "q1" : {
      "result" : { ... }
    },
    "q2" : {
      "result" : { ... }
    }
  }
}}}

The service should also support JSONP through a callback parameter.